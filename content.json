{"pages":[],"posts":[{"title":"基金定投","text":"四类基金货币基金、债券基金、混合型基金、股票型基金，收益和风险以此增加。 按照投资理念区分，股票基金分为主动型和被动型基金。 主动型基金需要在特定领域找到合适的基金经理，并且基金经理一般只擅长一个版块的分析，比较难把握。 被动型基金一般就是指指数基金，也是今天讲解的重头。 什么是指数基金根据一定标准（行业，国别，市值大小等）在证券市场选取一部分证券，被选定的证券共同构成一个指数，每个证券拥有一个确定的权重（即该证券在整个投资组合的所占比例），指数基金经理按照这个指数购买证券，建立一个与指数完全相同或者基本相同的投资组合，就构成一支指数基金。 总而言之，指数基金的构成就像是已经编制好，各个比例都已经事先规定好，基金根据指数调整，所以各家基本相似，所以同类的被动投资的指数基金，更换基金经理也不会有太大影响。 指数基金的好处由前面一小节知，指数基金是一系列证券基金的组合购买，多样性就意味着稳定性，所以他能够规避许多个例基金带来的风险，比如说“扇贝游走了”的獐子岛、“财务造假”的康美药业、“董事长性侵女孩”的新城控股等这种出现突发情况的股票。 基金定投基金定头，顾明思议，在固定的周期投入投金额购买基金，为什么要分批购买呢？ 基金单位份额价格变动快，分批投有助于摊薄购买成本，如果一次性买入，而恰巧单位价格比较高，那样会比较亏，分批则降低了风险。 避免纠结，省时省心。 定投策略的有效性在于基金净值的波动，即低买高出，所以混合型和股票基金比较合适，如果是那种债券和货币基金，基本没变动，根本得不到利润。 定投和一次性投资 一次性投资 一次性投资需要你天时地利人和占尽，在好的情况下买入，并且又要果断在正确的时机卖出，然而现实中，的确如果时机正确，一次性投资带来的收益是最大的，但是这种情况过于理想，人通常会犹豫不决，造成的后果也比较严重。 定投 在固定的周期买入，不需要具备择时的能力，而多次买入会降低风险和成本。 对比 假如计划投资1500元，计划投资3天，第一天净值为1元，第二天净值为0.5元，第三天净值0.6元，第四天卖出净值0.8元。可以采取的投资方法有两种： 方式一：一次性买入1500元，第四天卖出，投资亏损300元； 方式二：每天定投500元，第四天卖出，投资收益366.67元； 定投购买渠道新人建议：蚂蚁财富 如何选择合适的基金遵循一个原则：低买高出。 且慢估值网站 使用方法： 绿色区域：说明当前指数估值较低，有投资价值，可以开启定投或加大定投力度； 黄色区域：说明当前指数估值正常，可以暂停定投或减少定投金额； 红色区域：说明当前指数估值较高，可以考虑分批卖出； 支付宝红绿灯 和上面同理。 微笑曲线 在下跌的过程中买入而积累份额，同样的钱可以得到更多的份额，在价格反转后把握机会迅速卖出。 金字塔法则 把投资分成四份，分别是10%、20%、30%和40%，逐层递进，形成一个金字塔。当基金净值或股票股价逐渐上升时，买进的数量应逐渐减少，从而降低投资风险，反之，则应该逐渐增加购买的比例。 参考资料1.基金定投一定赚钱么 2.指数基金","link":"/2020/01/08/%E7%90%86%E8%B4%A2/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/"},{"title":"2SUM、3SUM、KSUM","text":"2SUM：Question: 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 Example: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路:1.暴力求解，遍历每一种可能，不予考虑。2.有没有什么办法够快速找到某一数的匹配序号而不用去遍历？Hash表。 class Solution { public int[] twoSum(int[] nums, int target) { HashMap map=new HashMap(); //建立 值-位置 的键值对映射。 for(int i=0;i","link":"/2018/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/2SUM%E3%80%813SUM%E3%80%81KSUM/"},{"title":"P，NP，NPC 和 NP-Hard问题","text":"P，NP，NPC面对的问题都是 答案为是或非的决策性问题。 NP-Hard的问题即不局限于答案为是非的，但是包含了是非。 P问题 能在多项式时间内找到解决方法的问题，比如图的2-color着色问题，我们现实中能找到复杂度在多项式时间解决的问题都是此类的。 NP问题 给与一个问题，可能你目前无法在多项式时间解决，但是如果给了你一个猜想的答案，你能在多项式时间检验 这个答案的正确性，这样的问题成为np问题。比如hanmilton回路问题， 给定一幅图，是否能找到一条经过每个顶点一次且恰好一次最后又走回来的路。 所以，所有的p类问题都是np问题，p是np的子集，但是p可不可能等于np问题至今仍是一个谜团。 NPC问题 npc特指一类特殊的问题，如果一个np的问题能够被规约转化（要求这个转化必须是多项式时间可以做到的）为该问题，即该问题的解法可以解决转化前的问题，那么这个问题就可以称为npc问题。 所以，npc问题是可以理解为np问题里面最难的那类问题，所有的np问题都可以泛华为该类问题。 比如，最大独立集，最大团 和 3-SAT问题。 NP-Hard问题 典型代表：停机问题。 np-hard问题的范围就广泛许多，它已经不局限于np问题的范围，npc问题都可以规约为np-hard问题，并且np-hard的问题也不再局限于回答是非的问题。 Reference： https://stackoverflow.com/questions/1857244/what-are-the-differences-between-np-np-complete-and-np-hard","link":"/2019/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA/P%EF%BC%8CNP%EF%BC%8CNPC%20%E5%92%8C%20NP-Hard%E9%97%AE%E9%A2%98/"},{"title":"Linux简单命令——echo","text":"使用将文本打印到标准输出位置，可以是terminal窗口，也可以是一个文件。 用法：echo [参数] [字符串] 譬如：echo hello, world!echo ‘hello, world!’ 对比两种方式，差别在哪？ 第一种方式，他会将 hello,和world作为两个独立的参数传递给echo程序打印，而第二种方式，他会将单引号内作为整体一个参数传递个echo指令。 为何要有这种差别？ linux系统中的变量以$开头，所以传递的是一个变量给echo的时候，他会打印变量的值，而如果用引号括起来就只会打印引号里的字面内容。转义字符处理 echo提供对单引号内字符串转义字符的处理，但需要加入-e选项参数。例如： 将文本输出到文件中 输出默认是输出到命令窗口，我们可以使用IO重定向符’>’来实现。 例如：你也可以使用‘>>’来向文本继续追加内容，因为’>’会覆盖掉内容，你可以根据需要选择。","link":"/2019/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94echo/"},{"title":"Linux——cd","text":"Note：/代表的是文件系统的根，可以理解一种表示范围限定的符。/下面有一个root目录，代表的是超级用户目录，两个是不同的概念。 cd .. 返回上次目录 cd ~ 转到用户目录 cd - 回到上一次所在目录 cd ../dir 回到上层目录后又进入dir目录 cd / 回到根目录","link":"/2019/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94cd/"},{"title":"gitignore如何编写","text":"前言我们使用git托管项目时，并不是所有文件都要托管，这时我们需要gitignore文件来指定哪些不要托管。 使用1.gitignore创建方式 在git bash中输入 1touch .gitignore 然后输入 1vim .gitignore 进行编辑，不熟悉vim的也可以使用记事本等编辑软件。 2.gitignore示例 12345# 只包含 foo/bar 文件夹 的 gitignore/* !/foo /foo/* !/foo/bar 3.gitignore编写规范（不怎么重要的规范就忽略了，这里列举我们常用的满足需求即可） 注：我们将gitignore文件的每行文字称之为模式（pattern），模式规定了怎样和文件进行匹配。 ‘#’ 号开头代表注释 ‘!’ 开头的模式代表此模式被无效化，该模式下的文件若之前被排除，将重新被git添加。 ‘/‘ 符作为文件夹的分隔符 如果模式中的头部或中间出现 ‘/’（尾部不满足），则此模式在gitignore文件路径同层开始起作用； 如果没有‘/’ ，任何比 gitignore文件 深 的文件都会被影响。 模式尾部出现’/‘，则该模式只匹配文件夹； 否则，文件夹和文件都会受影响。 Note：综合上面两条，我们可知 doc/frotz/ 能匹配 doc/frotz 文件夹， 而不能匹配 a/doc/frotz文件夹；但是，frotz/ 可以同时匹配 frotz 文件夹 和 a/frotz 文件夹。 单个星号 ‘*’ 通常用来替代所有可能的文本内容，比如 1*.txt 匹配所有txt格式的文件 两个星号‘**’ 通常用来指代所有可能的位置，比如 1234**/foo 匹配所有路径下的foo文件或文件夹/** 匹配所有内容abc/** 匹配所有abc文件下的所有内容a/**/b 匹配a文件夹下所有位置的b文件夹或文件，“a/b\", \"a/x/b\", \"a/x/y/b”都会被匹配 模式规范很多遵循正则表达式规范，读者应该好好学习一下。 4.gitignore示例解析 12345# 只包含 foo/bar 文件夹 的 gitignore/* 1.先排除掉所有文件夹!/foo 2.加入foo文件夹/foo/* 3.排除掉foo文件夹内所有内容!/foo/bar 4.加入bar4文件夹 编写方法总结：由外到里，逐步梳理要加入文件，排除文件，逐层深入。","link":"/2019/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA/gitignore%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99/"},{"title":"SSM框架学习——数据库、url-pattern导致的问题","text":"前言在学习SSM框架时，导入一个已有项目，修改了mysql等一系列常规配置后，发现要实现简单的运行，也存在着系列的问题，感觉也比较典型，作如下记录。 问题1. mysql 5 迁移到 mysql 8 12345678# 1. connector jar包 connector 5.0 -> connector 8.0 # 2. jdbc 驱动更改‘com.mysql.jdbc.Driver’ -> ‘com.mysql.cj.jdbc.Driver’# 3. 数据库连接的url更改jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8&serverTimezone=Asia/Shanghai 数据库设置迁移中有几个报错和注意，读者需牢记： serverTimeZone 大小写注意，错一个都不行。报错形式：java.sql.SQLException: No timezone mapping entry for … serverTimeZone的值设置有讲究，报错形式：The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized xml中使用实体符号代替直接输入& 否则tomcat报错如下：ERROR [main] - Context initialization failedorg.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 26 in XMLdocument from class path resource [applicationContext.xml] is invalid; nested exception # is org.xml.sax.SAXParseException; lineNumber: 26; columnNumber: 90; 对实体“serverTimezone” 的引用必须以 ‘;’ 分隔符结尾。 2. 为何需要设置时区？ 为什么普通的请求和我的时区也会有关系，时区对程序的影响是什么？ 请参考：https://blog.csdn.net/xiuliyan6124/article/details/80630293 mysql窗口中查看自己的时区是跟随系统的，而我们所在时区为东八区，你可以将时区调整为+8，或者将时区设置为Asia/shanghai即可。 1jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8&serverTimezone=Asia/Shanghai 3. 访问页面后直接返回的是jsp源码 错误原因：web.xml中url pattern 中 / 和 /*的不同 请参考：https://blog.csdn.net/xiuliyan6124/article/details/80630293","link":"/2020/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA/SSM%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81url-pattern%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"vector的resize和reserve","text":"官方文档resize：http://www.cplusplus.com/reference/vector/vector/resize/reserve：http://www.cplusplus.com/reference/vector/vector/reserve/ resize Resizes the container so that it contains n elements.1、If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them).如果n比当前容器size小，当前容器内容会被缩减到前n个，多余的被清除。2、If n is greater than the current container size, the content isexpanded by inserting at the end as many elements as needed to reach asize of n. If val is specified, the new elements are initialized ascopies of val, otherwise, they are value-initialized.如果n比当前容器的size大，容器size或被扩充到n，如果这扩充的n个数指定了数值，则填入指定数值，否则，为默认值。3、If n is also greater than the current container capacity, an automaticreallocation of the allocated storage space takes place.如果n比当前容器的容积都大，内容空间会被重新分配。Notice that this function changes the actual content of the containerby inserting or erasing elements from it.注意这个函数会影响容器的size。 reserve Request a change in capacity Requests that the vector capacity be atleast enough to contain n elements. 1、If n is greater than the current vector capacity, the function causesthe container to reallocate its storage increasing its capacity to n(or greater).如果n大于当前容器容积，容器会重新分配内存。2、In all other cases, the function call does not cause a reallocationand the vector capacity is not affected.其他情况，不产生影响Note：This function has no effect on the vector size and cannot alter itselements.这个函数对size 没有影响，也不会改变元素值。 size和capacity辨析类比： 12int a[10],index=5;for(int i=0;i>a[i] 10是我们开辟的空间大小，5是我们实际使用的空间，此空间的单位是元素个数，而非字节。那么对应的capacity对应开辟空间，size对应使用空间。 测试代码123456789101112131415#include #include using namespace std;int main(){ vector a; a.reserve(100); cout","link":"/2018/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA/vector%E7%9A%84resize%E5%92%8Creserve/"},{"title":"Sherwood思想寻找元素：","text":"引入：一个确定性算法A，（所谓确定，就是你不管运行几次，你的运行过程都是一样的），我们假设你是去二分查找一个元素，并且恰好是最差情况，运行了logn次，那么不管以后多少次运行这个程序，次数都是logn次。但是如果我们将middle值设为left-right中的一个随机值，那么每运行一次，过程都可能会不一样，我们知道随机就意味着平均化，每种结果都有可能，那么极端情况就会被避免，那么你的运行过程是最差情况的概率就会减小，而向平均情况靠拢。 用途：一个算法，存在最佳情况，和最差情况，还有平均性能，当最佳情况和最差情况相差很多，我们就可以用sherwood算法实现将算法的性能向平均对齐。这样以后，每次运行性能都在平均水平上，最差情况就被磨平了，对于其他情况意义不大。 实例演示：用舍伍德算法求乱序数组中值: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import randomlist1=[12,8,3,5,7,2,9] #[2,3,5,7,8,9,12]list2=[3,7,2,6,5,9] #[2,3,5,6,7,9]#实现列表中元素交换操作def swap(list,a,b): temp =list[a] list[a]=list[b] list[b]=temp#pos是寻找第几小，left是左边界，right是右边界def select(list,left,right,pos): while True: if left>=right: return list[left] #从left-right中随机选择一个作为比较的轴值 r = random.randint(left,right) if left != r: swap(list,left,r) #将轴值放在数组开头，好方便以后的交换操作 pivot=list[left] i=left+1 j=right while True: while i=i:#从右往左找到不大于轴值的元素 j=j-1 if i>=j: break swap(list,i,j) #将找到的两个元素交换 #将轴值放回它应在的位置，此时左边都不大于它，右边都不小于它。 list[left]=list[j] list[j]=pivot #重新确定寻找区间，找到就返回 t=j-left+1 if t==pos: return pivot elif t>pos: right=j-1 else: pos=pos-t #这里注意当左边界收缩时，它的pos也要收缩 left=j+1print(select(list1,0,len(list1)-1,4))","link":"/2018/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%B8%AD%E5%80%BC%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94Python%E4%B8%ADSherwood%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"},{"title":"vps实现ss代理","text":"通过shadowsocks来实现科学上网已经是家常便饭，今天就如何配置做一篇分享。 适用环境服务端：centos 7 系统 适用客户端：windows 10 、 移动端 具体步骤1.注册vultr账号&充值 一般需要选购国外服务器，而国内的服务器提供商虽然可以买到境外服务器，但是一般都禁止安装shadowsocks服务，这里推荐 vultr（使用该链接注册提供50$的体验费用，如果活动已过，通过访问 vultr2 注册账号）。 账号注册完毕，点击billing可以来到充值界面，并且这个网站可以使用支付宝 、 微信进行支付，非常方便。 支付完毕，账号就可以有60$到账。 2.下载服务器连接工具：mobaxterm mobaxterm，是一个免费的，功能齐全的远程连接工具，界面美观简洁。 3.选购合适的vps&部署shadowsocks服务端 点击左侧products 选择服务器类型 选择服务器地点 选择服务器系统 选择服务器规格 最后点击deploy now， 服务器就开始部署了。 4.检查服务器是否可用 由于监管原因，有些服务器ip地址或者ip地址是被封禁的，所以我们首先需要检查一下服务器是否可用，如果不可用，则你需要删除这个服务器实例，回到步骤3重新部署一个服务器，你可以选择一下子部署多个，然后挨个测试，遇到成功的把多余的删除即可。 检查ip是否可用 如上图，当你的服务器部署完毕，会提供给你一个ipv4地址，你在本地机器上ping 这个ip地址，如果最后ping不通，则服务器不可用。 检查端口是否可用 当你可以ping通你的ip，别高兴太早，可能你的22端口被封，检查端口，你需要进入mobaxterm， 点击session 选择ssh 输入服务器信息 如果端口没有封，他会提示你输入登录密码，登录密码需要你在vultr中点击服务器查看具体信息。 5.部署shadowsocks服务端 进入之后，部署很简单，只需要按顺序输入几条命令。 1.下载shadowsocks 1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 2.提升权限 1chmod +x shadowsocks.sh 3. 1./shadowsocks.sh 2>&1 | tee shadowsocks.log 总共三条命令，中间会提示你输入服务器IP地址和端口，端口是你自己指定，选择范围在1-65536。 另外，中间还会选择加密方式，一般选择7，即aes-256-cfb。 完成之后，会给你一个服务器端的具体信息清单，你记得截图保存。 6.客户端安装shadowsocks 去下载列表中选择对应版本shadowsocks， 解压之后，直接点击纸飞机图标运行程序，根据你自己的配置填写进去就可， 7.设置pac 如果不设置pac，所有的浏览器访问都需要经过代理，包括国内的，这是没必要的，会造成响应慢，pac模式指的是只有被墙的网站才使用代理访问。 你的右下角任务栏里会有小飞机图标，右键 -> 系统代理 -> pac模式。 8.开始你的科学上网","link":"/2019/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA/ss%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E9%85%8D%E7%BD%AE/"},{"title":"五子棋人机博弈","text":"五子棋，人与人之间博弈，我们不用考虑太多，都是玩家自动思考。但是如果我们要玩一个单机的五子棋，实现人机的对战，那么我就得“帮”电脑考虑下走哪步了。实现的方法大概有三种： 最大权值法 决策树法 机器学习训练 这里我们主要针对第一种方法讨论下，大致思路如下： 我们绘制好一个棋盘后，假定大小为 15*15； 下棋之前，对于棋盘中的每个空位，我们每都替电脑人“掂一掂”下在哪里合算；(估权过程) 对每个空位按照规则都计算完权重，我们找出权重最大的位置，此位置就是npc落子位置 那么现在的问题就是，这个权重的计算规则是怎样的呢？首先，我们思考一下人是怎么下子的。 当该位置四周为空时，这个位置落子可能就不是那么有意义； 我们最大可能地去实现将棋子相连，若该位置四周已出现一条连线，则连子数越多，该子越重要 就算一条线有很多子已经相连，如果该线的一端被堵住，那么该线的重要程度降低，我们称之为眠连，otherwise，两端都没堵住我们称之为活连。 现在我们来将棋子相连的情况进行下归类赋权空子位置我们用 “0” 表示，白子用“2”表示，黑子用“1”表示；我们主要分为以下几种情况： 定义 棋子相连情况 权值 活一连 010、020 40 活二连 0110、0220 400 活三连 01110、02220 3000 活四连 011110、022220 10000 眠一连 012、021 20 眠二连 0112、0221 200 眠三连 01112、02221 500 眠四连 011112、022221 3000 主要被分为了以上几类，当然可以考虑更多以使你的npc更加“智能”； 现在考虑算法 对于每个空位，我们从四个方向进行考察: 水平 竖直 左斜 右斜 我们以水平方向为例进行代码考察： int go[row][column]; //记录每个点的落子情况 int weightarr[row][column]; //记录每个空位的权值 for piece in chessboard{ if(piece为空){ key1=\"0\"; //记录空位左边连子情况 key2=\"0\"; //记录空位右边连子情况 (i,j)为空位坐标 ux=i;uy=j; //(ux,uy)记录左边连子边界 dx=i;dy=j; //(dx,dy)记录右边边界 first1=0; first2=0; //first1 记录空位左边第一个子颜色，first2记录右边第一个颜色 //while的目的在于找到最多的颜色相同的连线 while(左边不越界){ int first=go[i-1][j].color; first1=first; if(first==0) break; //如果空位相邻也为空，退出 else { //如果不为空位 --ux; if(颜色和first相同) { key1+=go[ux][uy].color; } else { key1+=go[ux][uy].color; break; } } } while(右边不越界){ ... //和上面同理 } value1=左边连线权值； value2=右边连线权值； if(左右连线颜色相同） 权值翻倍； weightarr[i][j]+=该方向权值； //同理，依此计算 左斜，右斜，竖直情况； } }要注意的是，因为对于每个大方向，比如说水平方向，我们以该空位做间断点分了水平左和水平右，当水平左和水平右的颜色相同时，权值注意要加强，因为比如说隔开的2个黑子和1个黑子填上空位可以变成4个黑子； 大家可以具体自己重新设置权值，添加更多情况。我们将具体实现代码放在github中，供大家参考：https://github.com/Gray-way/Gobang","link":"/2018/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%BA%94%E5%AD%90%E6%A3%8B(%E4%BA%BA%E6%9C%BA%E5%AF%B9%E5%BC%88)%E2%80%94%E2%80%94Java%E6%9D%83%E5%80%BC%E6%B3%95%E4%BA%94%E5%AD%90%E6%A3%8B%E5%8D%9A%E5%BC%88/"},{"title":"单源最短路径——Python分支限界算法实现","text":"题目分支限界具体见百度。 分支界限算法核心思想： 在每次分支后，对凡是界限超出已知可行解值那些子集不再做进一步分支。这样，解的许多子集（即搜索树上的许多结点）就可以不予考虑了，从而缩小了搜索范围。 个人理解什么叫分支限界？演示如下:（以ＦＩＦＯ队列方法做演示）１.将这个图转化成树的形式，如下所示： 创建队列。 １．节点１入队列，Ｑ＝｛１｝。 我们取出队头节点，作为扩散节点，更新他的后代的值。 此题中更新节点２，３，４ 的距离，并将他们加入队列，Ｑ＝｛１，２，３，４｝。 完成后节点１出队。Ｑ＝｛２，３，４｝。 ２. 同样，重复１的步骤，Ｑ＝｛３，４，５，６｝； ３. 当我们取到节点３时，我们发现源点－＞节点３－＞节点６的距离为１１， 大于 １－２－６ 这条路径的权重，所以１－３－６这条路径之后我们不再考虑。 这就是“限界”（称为”剪枝“）的思想。 ４. 重复步骤，直到Ｑ为空。 优先队列法方法和FIFO方法类似，区别在于优先队列每次取队列元素中到源点距离最短的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 初始化图参数 用字典初始初始化这个图G = {1: { 2: 4, 3: 2,4:5}, 2: { 5: 7, 6: 5}, 3: {6: 9}, 4: {5: 2, 7: 7}, 5: {8: 4}, 6: {10:6}, 7: {9: 3}, 8: {10:7}, 9: {10:8}, 10:{} }inf=9999#保存源点到各点的距离，为了让顶点和下标一致，前面多了一个inf不用在意。length=[inf,0,inf,inf,inf,inf,inf,inf,inf,inf,inf] Q=[]#FIFO队列实现def branch(G,v0): Q.append(v0) dict=G[1] while len(Q)!=0: #队列头元素出队 head=Q[0] #松弛操作，并且满足条件的后代入队 for key in dict: if length[head]+G[head][key] length[v]: min=length[v] flag = v head = flag dict=G[head] #找到扩散点后进行松弛操作 for key in dict: if length[head] + G[head][key]","link":"/2018/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94Python%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"},{"title":"单例模式——多线程优化","text":"double-check 和 synchronized 实现单例模式在多线程下的优化。public class Singleton { private volatile static Singleton s=null; private Singleton(){} public static Singleton getInstance(){ if(s==null){ synchronized (Singleton.class){ if(s==null){ s=new Singleton(); } } } return s; } public static void print(){ System.out.print(\"this is the print function\"); } public static void main(String[] args){ Singleton s=Singleton.getInstance(); s.print(); } }1.为什么不在成员变量里直接new？ 没有必要在类加载时就实例化，节省空间。 2.synchronized有什么作用 防止多线程下会创建多个实例。 3.为什么synchronized里还有一个null判断 第一个线程创建后，后面线程就没有必要创建了，所以s是volatile定义的。","link":"/2019/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/"},{"title":"位图法与N个数中找最大10个数","text":"前言今日，听得同学间讨论两个问题，觉得甚是有趣，一个是找到n个数找最大10个数，另一个是位映射的问题。 一、N个数找最大10个数引入：给定n个数据，比如10万，又或着100万，让你找到最大前10个数，怎么找呢？我心中不免一惊，真的是很巧，之前我在做数字手写识别时就考虑过这个问题，knn算法有涉及从n个邻居中找到k个最近的邻居，二者问题本质是一样的。听到有人不假思索，直说：“排序”。我们分析是不必的，我们只需要找到最大的10个，对次序并无要求，排序让整个数据有序是没有必要的。 想法：看过我那篇文章的同志应该知道我是用了一个“最值淘汰”的方法，想法很简单，我们只要不断把10个数中的最小值和剩余数比较，淘汰掉小的数，这个过程可以看作是一个不断提升最小值下限的过程。基本思路是这样，如何实现则又是一个优化过程。因为剩余所有数我们肯定都要遍历一遍，已经无法进一步优化，那么唯一能优化的只有一个问题了——我们如何找到10个数中的最小值？ 数组每次遍历10个数 遍历m个数操作复杂度为O(m)。从N个数中找到最大M个数，则总的复杂度为O(n*m); 10个数用堆存储 建堆复杂度为O(m),我们先将前m个数建堆，因为是不断提高最小值下限，我们要建一个最小堆，每次都是和根节点比较，如果交换了值，就要对堆重新维护一次，因为维护的代价为O(logm)，所以总的代价为O(nlogm);关于堆排序的实现，可以参考我的另一篇博客：基于比较的内排序——温故而知新 最后讨论，还是堆结构比较方便，后来想，对于大数据，数据的重复量也是影响效率的因素，我们对数据的预处理去掉重复数据，也潜在可能提高效率。那么关于大量数据的重复性我们如何检验呢？ 顺水推舟，我们又来考虑大量数据怎么检查重复性呢？ 二、位映射也是假设1亿个int数据，在32位机内存上运行，让你过滤掉重复的数。 讨论： 同样，我们否定掉每找一个数就和后面的数进行比较的思路，int型数据可表示的数一共有$2^{32}$=4294967296种，这样最差情况下复杂度达到O($n^2$)，是不理想的。 我提出的是采用Hash表的方法，我们将数值作为key，出现次数作为value,只需要遍历一遍，value不为1就是重复的，后来一想，这样也是不理想的，因为32位机的内存只有4GB，如果重复较少，根本存不下。 经老师提点，采用位图法：我们知道int一共有$2^{32}$种，我们可以申请$2^{32}$bit 的数组空间，这样对于每个int数我们都可以有对应的位置映射，当出现了int最小值，我们就将数组0号位置置1，如果再次出现0，因为已经置1，所以判定为重复。这个方法，我们存储空间就缩小为 $2^{29}$bit=512MB。但是考虑到实现部分时，我们知道计算机最小可操作单位是1Byte，位图法则要求到bit精度，所以这又涉及到一个byte和bit之间的转换。 算法实现思路： 既然最小操作单位是byte，我们分组即可，每8个bit就是一个byte，所以我们申请长度为$2^{29}$的byte数组即可。 如果没有申请byte数组，我们是从左往右直接数来确定某个bit位，有了byte数组，我们没有本质改变，只要先确定组号，再确定组内偏移一样可以定位。 怎么才能实现对单个bit位进行赋值修改呢？ 又涉及到一次转换，因为操作单位是byte，我们只能通过对这个byte单位进行赋值修改某个bit，通过十进制和二进制的转换我们可以实现，比如对于某个byte，我们要让第三个0置1，我们只要对该byte赋值4即可。 0000 0100 = 4 我们怎么判定重复呢？对于某个数必须要知道它的位置是否被置1，一种方法是通过移位单独取出该位，第二种方法则是 按位相与—— &。比如某个byte内部： 0000 1100 = 12 我们要判断4的重复性Method 1：逻辑移位 对12左移2位后取出剩余首位是否为10000 0011 Method 2：按位相与 0000 1100& 0000 0100= 0000 0100可见，只要重复，那么按位相与结果必定不为0； 实现如下：环境：IDEA语言：Java 1234567891011121314151617181920212223public class Repetetive{ public static void main(String[] args){ byte[] res=new byte[1","link":"/2018/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E4%BD%8D%E5%9B%BE%E6%B3%95%E4%B8%8EN%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A710%E4%B8%AA%E6%95%B0/"},{"title":"单链表的反转","text":"单链表的反转 单链表概念引入有一个空的head节点作为头节点，头节点的存在主要是为了操作的统一性而设立的（删除增添节点等操作能够统一，不需要特殊考虑单独情况），当然它不是必须的，它的数据域毫无意义。 我们的目标：实现单链表的反转1.如果考虑不破化原有链表，实现单链表翻转。这个实现比较简单，主要考虑在复杂度上，如果每次都取最后一个元素再插入新的链表，那么每次都要从头开始遍历一遍，复杂度为O($n^2$),但是我们可以考虑循环一遍将元素放入栈中，然后弹出实现反转。 2.在原有结构上实现反转。最理想的方法当然是遍历过去一遍实现，要怎么办？ 思路如果只有只有一个元素，不用操作；如果多于一个元素，我们考虑到如果直接让后一个元素的next域指向前一个元素，那么再后一个元素的位置我们就无法确定，所以在将后一个元素的next指向前一个元素之前，我们将原本的next的指向元素保存就可以了。 看示例图： 我们借助两个移动的游标来完成工作，每次要改变 cursor2.next 的方向前，我们先用tmp保存好原来的cursor2.next指向的元素。 这样当cursor2.next完成赋值后： 我们记录了tmp的位置，之后两个cursor同时移动： 重复操作： 通过这个方法，我们就可以实现两个cursor的移动，实现迭代。 最后当tmp为空，循环截止； 实现代码： public void reverse(){ if(size==1) return ; int count=0; Node cursor1=root.next; Node cursor2=cursor1.next; while(cursor2.next!=null){ Node tmp=cursor2.next; cursor2.next=cursor1; if(count==0){ cursor1.next=null; count++; } cursor1=cursor2; cursor2=tmp; } cursor2.next=cursor1; root.next=cursor2; } 测试代码: 123456789101112Node结点类：public class Node { public Node next; public int data; public Node(){ next=null; } public Node(int data){ this.data=data; this.next=null; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273链表实现:public class LinkedList { private int size; private Node tail; private Node root; public LinkedList(){ this.size=0; tail=root=new Node(); } public void append(int data){ tail=tail.next=new Node(data); size++; return ; } public void insert(int data,int index){ if(indexsize-1){ System.out.println(\"index错误\"); return ; } Node cursor=root; for(int i=0;i","link":"/2018/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/"},{"title":"图的链式前向星","text":"导航resize和reserve的差别：https://blog.csdn.net/Gease_Gg/article/details/83785584 原理info[i]: 存储起点为i的第一条边在next和to中的下标值。next[i]: 该点下一条相邻边在next和to中的下标；to[i]：该边所指向的结点编号；细致原理参考：https://malash.me/200910/linked-forward-star/ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include #include using namespace std;struct Graph{ typedef vector VI; VI info,next,to; Graph(int n=0,int m=0) : to(0),next(0){ info.resize(n,-1); next.reserve(m); to.reserve(m); } int edgeSize(){ return to.size(); } int vertexSize(){ return info.size(); } void expand(int i){ if(info.size()","link":"/2018/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%9B%BE%E7%9A%84%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"},{"title":"基于比较的内排序——温故而知新","text":"引言排序和检索是数据数据的两个关键部分，排序是想尽快有序组织数据，检索则是想尽快查找数据。最近发现对这个知识点里的部分内容生疏，所以特此做个总结。 环境IDE：Eclipse语言：Java 排序分类 排序算法在实现方法上被分为两个大类，我们今天讲的是基于比较的排序算法，非比较算法我们稍后再谈。 几大排序概览一、性能 | 名称 | 时间复杂度 | 空间复杂度 | 稳定性|| ————- |:————-:| —–:|| 选择排序 | O($n^2$) | O(1) | 不稳定| 冒泡排序 | O($n^2$) | O(1) | 稳定| 插入排序 | O($n^2$) | O(1)| 稳定|shell排序 | O($n^{1.5}$)| O(1) | 不稳定|堆排序 | O(nlgn) | O(1) | 不稳定|归并排序| O(nlgn) | O(n) |稳定|快速排序| O(nlgn) | O(lgn) |不稳定 二、具体介绍A、选择排序简介：每次选择最大或者最小的元素放到指定位置。每次交换必然导致元素顺序的变换，所以是不稳定的。 12345678910111213public int[] selectSort(int[] a) { int len=a.length; for(int i=0;ia[j-1]) { int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; flag=true; } } // 如果该轮没有交换说明数组已经有序，直接退出； if(!flag) break; }} in: int a[]= {4,5,1,8,4,9,2}; out: 9 8 5 4 4 2 1 C、插入排序简介：维护两个数组，一个有序，另一个无序，每次从无序数组中取一个元素，在有序数组中按固定顺序比较找到位置插入即可。麻烦点在于后面元素的挪动。同样，插入一个元素不会改变元素的相对位置，所以也是稳定的。 123456789101112//个人改进版，边找位置边挪，不用先找到位置再挪。public void insertSort(int[] a) { for(int i=1;i=0 && a[flag]>num) { a[flag+1]=a[flag]; flag--; } a[flag+1]=num; } } in: int a[]= {8,5,1,4,9,2}; out: 1 2 4 5 8 9D、归并排序简介：两个有序数组如何合并成一个有序数组？假设两个数组都是从小到大排序，我们只要不断比较两个元素的头元素，把较小的元素拿出来接在新开的数组里面就可以了。采用递归的方式实现。合并时，相同元素排放规则是固定的，所以归并排序也是稳定排序。因为需要一个数组b来做中转，所以空间代价为O(n). 1234567891011121314151617181920212223public void mergeSort(int start,int end,int[] a,int []b) { if(start==end) return ; int mid=(start+end)/2; //递归分解 mergeSort(start,mid,a,b); mergeSort(mid+1,end,a,b); for(int i=start;i","link":"/2018/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E5%86%85%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"},{"title":"堆","text":"性质 ​ parent(i) = i/2 向下取整； ​ leftchild(i) = 2*i ​ rightchild(i) = 2*i + 1 对于一个长度为n的数组建堆： ​ 首先从第一个非叶子节点开始进行maxheapify操作。 ​ 第一个非叶子节点位置：n/2 向下取整 maxheaplify操作： ​ 将堆顶元素和两个孩子节点比较，如果小于两者其中一个，和其中较大的进行交换，迭代进行这个操作，直到整个堆构建完毕。 code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include using namespace std;void swap(int* a, int src, int dest) { int t = a[src]; a[src] = a[dest]; a[dest] = t;}void maxHeaplify(int* heap, int N, int i){ int right = 2 * i + 1; int left = 2 * i; int largest = i; if (left < N && heap[left] > heap[largest]) { largest = left; } if (right < N && heap[right] > heap[largest]) { largest = right; } if (largest != i) { swap(heap, largest, i); maxHeaplify(heap, N, largest); }}int main(){ int n; cin >> n; int heap[n]; for (int i = 0;i < n;i++) { cin >> heap[i]; } for (int i = n/2;i >=0 ;i--) { maxHeaplify(heap, n, i); } for (int i = 0;i < n ;i++) { cout < heap[i] < \" \";","link":"/2019/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%A0%86/"},{"title":"找到两个有序数组的交集","text":"背景对于下面两个有序set，找到出他们的交集： 12list1=[2,3,8,10,12]list2=[3,10,12,22] 方法1、计数器对两个list分别遍历一遍； 12345678910111213141516#include using namespace std;int main(){ int a[]={2,3,8,10,12};int alen=5; int b[]={3,10,12,22};int blen=4; int count[1000]; for(int i=0;i","link":"/2018/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"title":"如何优雅地退出多重循环","text":"C++1、 采用goto语句goto语句虽然一直被大家所诟病，说破坏了代码的结构化特性，但是它也有自己的好处。goto语句肯定不推荐大量使用，但是对于跳出多重循环还是特定方便，逻辑也比较清晰。 1234567891011121314#include using namespace std;int main(){ for(int i=1;i","link":"/2018/11/04/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%80%80%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF/"},{"title":"字节流和字符流探究","text":"前言以前在学习流概念的时候，一直会被提到字节流和字符流，也经常涉及到各种编码方式，如ASCII和UNICODE，但老师告知文本传输最好使用字符流，而其他的最好使用字节流，虽然知道用法，但是还是心中有所疑问，今天就探究之后做如下记录。 编码ANSCII编码计算机是美国人过出来的，所以一开始他们只需要考虑现实英文字母，而英文字母只有26个，外加上计算机上的其他32个不可显示字符和符号等，1个字节（可以表示256个不同的状态）的编码方式显然对他们足够了。 所以，ASCII一共规定了128个字符的编码，包括了英文字符和所有其他字符，这128个字符只占用了字节的后7位，开头一位统一规定为0。 非ANSII编码的产生ANCII只支持英文字符的现实，而地球上那么多语言，比如中文，德文，日文，每种语言的字母个数都不同而繁多，所有anscii编码对他们远远不够，所以在这阶段许多国家都有自己的编码标准，比如中国的GB2312,使用了两个字节表示 一个汉字，最多表示了 65536 个汉字。 Unicode正如前面所言，多种编码方式给不同语种之间的通信带来了很大的麻烦，经常会遇到文件打开乱码的情况，所以提出了一种包含了所有符号的编码方式——Unicode编码，现在Unicode编码已经包含了百万多的符号，具体的符号索引，可以查询 unicode.org。 注意，unicode虽然规定了符号的二进制编码形式，但一个字符存储到电脑上的二进制代码又是不同的，因为计算机并不能根据unicode编码知道字符占几个字节，简单来说，它需要一次编码解码过程，即将unicode进行编码成新的二进制代码存储到电脑。为什么需要这样做呢？我们知道，英文只需要一个字节就可以表示，汉字则最少需要两个字节，可能还有其他的需要3-4字节，如果unicode统一规定所有符号都用4字节编码表示，那么每个英文字母前面都有2-3字节是0，这将造成极大的浪费，所以需要一种具体落实unicode编码的技术——即UTF8、UTF16和UTF32都是实现unicode字符存储的实现方式。 UTF-8utf-8是当前应用最广的unicode实现方式，正如我们前面所说，为了解决浪费问题，它是一种变长编码方案，它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 他的编码规则很简单： 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码 下表总结了编码规则，字母x表示可用编码的位。 1234567Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx （11表明了占用两个字节，第二字节开头10占位）0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx （111表明符号长3字节）0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx（1111表明符号长4字节） 例子，严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 过渡之前说了编码方式的由来，之后将基于java来探讨下编码和字节流、字符流之间的关系。 字节流计算机的最小存储单位是字节，所有文件，如视频、音频等等，亦包括文本，都将转换成二进制的字节流存储，所以其实从根本上来讲，后面的字符流只是在字节流上做了一层字符编码解码的工作。inputstream和outputstream是专门为字节流服务的两个类，字节流的应用偏向于非文本文件，应用比较清晰明了，不做赘述。 字符流我们说，字符流是字节流的包装，只是在字节流之外添加了一层字符集，只要我们指定字符集就可以实现对应的编解码，从java的继承层次上我们可以看到这层关系。 InputStreamReader是读取字符流的类，该类里面有成员StreamDecoder，而StreamDecoder 又包含了InputStream和Charset, 所以我们可以很明显知道，字符流其实是对字节流的包装。 对应的，outputStreamWriter是写入字符流的类。 在我们的应用程序中涉及到 I/O 操作时只要注意指定统一的编解码 Charset 字符集，这样一般不会出现乱码问题，有些应用程序如果不注意指定字符编码，中文环境中取操作系统默认编码，如果编解码都在中文环境中，通常也没问题，但是还是强烈的不建议使用操作系统的默认编码，因为这样，你的应用程序的编码格式就和运行环境绑定起来了，在跨环境下很可能出现乱码问题。 ​ ——选自参[2] 扩展场景的不同对编码方式的要求不一样，不一样的编码会导致效率等的不同，常见需要编码的场景是磁盘io和网络io，网络io需要经常用到编码，包括url、cookie和http header等，这里面的应用可以参考深入分析 Java 中的中文编码问题。 参考1.字符编码笔记：ASCII，Unicode和UTF-8 2.深入分析 Java 中的中文编码问题 3.Java 中字节流与字符流的区别?","link":"/2020/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E6%8E%A2%E7%A9%B6/"},{"title":"树状数组","text":"应用一个用来快速计算数组前缀和的数据结构，就像一个数可以用2的多次幂的组合相加表示，一个数组的前缀和也可以是多个序列的加和表示，二者之间也存在着一些巧妙的联系。 如下图所示，A数组是原数组，C数组是前缀和数组，从这个结构来看，C数组的和计算是一个树状的形式。 12345678C1 = A1C2 = C1 + A2 = A1 + A2C3 = A3C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4C5 = A5C6 = C5 + A6 = A5 + A6C7 = A7C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 树状数组的好处树状数组c保存的是部分序列和，对于区间求和，比如求A[1] ~ A[6]我们需要使用C[4] + c[5] + A[6]; 有人说我们可以使用这样一个数组t, t[i] 保存 A[1] ~ A[i - 1]的和，这样岂不是O(1)时间就可以得到结果？ 的确，这样的确更快，但是如果我们需要修改原数组中的一个值，比如说A[k], 那么所有包含A[k]的T元素都应该修改，这样的代价就边成了O(n)，而树状数组只需要修改部分元素，所以树状元素其实是对查询和修改的一个折中方案。 详细原理树状数组的核心是c数组，c数组的原理是存储部分序列的和，那么这些序列是怎么划分的，怎么知道c数组元素记录的是哪段序列的和呢？ 我们先讲结论 c数组定义 对于c数组元素下标 i 为0x###100 (1是从右到左第一个1)，那么他记录的区间是（0x###000,0x###100], 即起始位置为0x###000 + 1(对应的1变为0)，长度为100 (最右的1和它右边0构成) 的序列的和。 例如，对于上节图中才c[6]，6 = 0x110，他记录的区间位置为 (0x100, 0x110]。 这就是他树状数组核心c数组的定义，就这么简单。 但是，正如你想要深入了解，特殊的构造背后，是一些优美的性质。 c数组下标的一些性质我们从一开始的图中发现，c数组的元素构成了一个逻辑上的树，这是由于他下标和定义带来的优美性质。 性质 #1 c数组中，下标为0x###100的元素，他有唯一的父节点,其下标为0x###100 + 0x100(最右边1和0构成的值) = 0x##1000。 例如： 0x###100的父节点是 0x##1000， 0x###110的父节点也是 0x##1000， 0x###111的父节点也是 0x##1000。 性质 #2 c数组中，下标为0x##1000的元素，他有如下儿子节点,其下标为 0x###100 、 0x###110 、0x###111和元素组中的A[0x###100] 根据上一节对c数组的定义我们知， c数组里0x###100 、 0x###100 、0x###111构成了对0x##1000所表示区间的不重叠划分。 而0x###100和0x###100我们也可以再递归拆分成几个序列的和。 实现操作我们发现，上面两条性质中，有一个重要的操作就是要获取最右边1和所有0构成的值，有什么好的实现呢？ 代码中，我们可以用如下操作实现： 123int lowbit(int x){ return x&(-x);} 计算机中，采用补码形式表示int值，补码的性质在于取相反数时，原数中所有二进制位都取反，然后末尾+1。 比如二进制中6的相反数-6的求取过程如下： 1236 = 0x110；-6 = 0x001 + 0x1= 0x10； 而6 & -6 我们发现正好等于0x10，即6的最右边1和所有0构成的值。这个很好理解，因为-6对6原位都取了反，取反+1之后从右往左的1就是原数左右边的1，自己脑子里多过遍就很好理解。 全部代码 12345678910111213141516171819202122232425262728293031323334353637383940414243int c[100]; int a[100]; // 注意a[0] 和 c[0]是不被使用的int n = 10;int lowbit(int x){ return x&(-x);}void init(){ // 初始化c数组，c数组的原理对应我们之前讲的性质1 for(int i = 0;i < n;i++){ c[i] += a[i]; int j = i + lowbit(i); if(j = 1){ ans = ans + c[x]; x = x- lowbit(x); } return ans;}// 偷个懒，只需要修改上级，而不修改原来的数组 void add(int x, int k){ while(x","link":"/2020/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"title":"数字手写识别——Java实现KNN算法","text":"引言手写识别也是当前机器学习的一大热点，数字手写识别是手写识别中的基础，我们用到的是knn算法，今天给大家讲一下我的实现方法； 环境IDE：Eclipse语言：Java 项目：数字手写识别思路数据采集：我们知道，一张图片可以被看作一个个点组成的矩阵，对于手写数字，我们只要创建一个全0数组当作背景，手写完毕把数字所占区域置为1，就可以保存当作一个样本了，如下图所示。算法:KNN算法，其距离度量我们采用欧拉距离。欧拉距离计算方法：我们将数组看作40*40向量，采用距离公式计算。 实现一、面板请原谅作者对于美笨拙的感知，我所绘制的界面不能够再简单了。如图: 面板按钮介绍： Identify：识别手写的数字； Save this example: 保存这个样例到数据集； 数字下拉框：相当于保存数据集的标签，例如，要保存手写“2”，先下拉选好2再保存即可 二、存储在数据读取存储上走了很多弯路，之后要好好总结下数据流的几个传输方式。我们将每张图片转化为一个二维数组后，存放进一个txt文件中。对于每个单独的文件，我们要产生一个独一无二的文件名，所以文件取名方式采取“数字+随机id .txt”的格式命名，随机id我们通过构造UID对象，获取其hashcode值作为id。 1234567891011121314151617181920212223242526//获取下拉框选中的数字String selectedNumber=cbItem.getSelectedItem().toString();UID id=new UID();//文件的前缀路径String rootPath=\"C:\\\\Users\\\\DearYou\\\\eclipse-workspace\\\\GUI\\\\src\\\\Demo\\\\handwritingIdentify\\\\TrainingData\\\\\";//生成文件名String fileName=selectedNumber+\"-\"+id.hashCode();//生成绝对路径下的一个文件String absoluteFile=rootPath+fileName+\".txt\";File file=new File(absoluteFile);try { //创建文件 if(!file.exists()) file.createNewFile(); //将数组写入文件 FileWriter out = new FileWriter(file); for(int i=0;i","link":"/2018/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E5%AD%97%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB%E2%80%94%E2%80%94Java%E5%AE%9E%E7%8E%B0KNN%E7%AE%97%E6%B3%95/"},{"title":"递归实现单链表的反转","text":"递归实现单链表的反转之前用迭代实现了链表反转，受同学启发，也可以用递归方式实现，如下。对于链表结构，还是采用单链表的反转里面的结构。 注意： 由于递归的操作是规模缩小，操作重复的，所以递归时直接从第一个数据结点开始（不是从空的头结点开始），虽然可以每次回溯时都让。 123456789101112131415代码如下：public void reverse2(Node datahead){ //递归一直到最后一个结点，此时将head头结点指向末尾，末尾数据结点变成新的头数据结点 if(datahead.next==null){ root.next=datahead; return ; } //保存该结点的下一个结点 Node secondnext=datahead.next; reverse2(secondnext); //改变相邻结点的方向 secondnext.next=datahead; //新的数据结点置为空，不然遍历死循环。 datahead.next=null;} 示例图：1.一直递归压栈，直到回归条件2.开始执行递归后面的语句，进行弹栈回溯一直到最后数据结点方向完全改变：","link":"/2018/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/"},{"title":"树同构判定","text":"树同构判定图同构与树同构 同的同构问题还没有有效算法。 树的同构本质上寻找不同树之间的双射关系。 通过对树编码，将树的同构问题转化为编码比较问题。 有根树的同构严格强于图同构关系。 如上，图同构的两张图转化成树，如果选取的根不同，则树不同构。 如何选取根？ 概念定义： dis(v1, v2)表示v1到v2点的距离 ex(v), 偏心率， ex(v)保存树中距离v最远的点的距离。 ex(v1) = max(dis(v1, vk)) , k = 1 → n C(T), 成为中心，表示图中偏心率最小的点集合。 一种重要性质 对于一个树来说(对于图不成立)，他的中心最多含有两个点，且若含有两个点，这两个点必定相邻。 所以，寻找一个树的中心，只需要迭代地删掉叶子节点，最后剩下的单个节点或者两个节点就是树的中心。 树的编码（有根树的同构判定） 将树转换字符串，但是通过比较字符串的字典序来比较两个编码的大小关系。 字典序比较规则：编码方法 采用如上编码方案，两个树只有编码相同的时候才会同构。 reference https://zh.coursera.org/lecture/discrete-mathematics-ch/you-gen-shu-tong-gou-de-pan-ding-NAxTd","link":"/2019/11/06/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A0%91%E5%90%8C%E6%9E%84%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/"},{"title":"不重复随机数字生成","text":"问题：0~n之间不重复随机数字方法一random_shuffle： //C++ 原生接口，思想是对0~n之前打乱顺序，即产生随机数字 template void random_shuffle (RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator& gen) { iterator_traits::difference_type i, n; n = (last-first); for (i=n-1; i>0; --i) { swap (first[i],first[gen(i+1)]); } } 方法二//思想同样是对数组进行操作，结果保存在a中。将选中的数字用未被选中的数字换掉。 void gen_three_nums(vector& a,int boundary){ int start_array[boundary]; for(int i=0;i","link":"/2019/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%9A%8F%E6%9C%BA%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%94%9F%E6%88%90/"},{"title":"transient关键字与序列化","text":"背景序列化 在编码过程中，我们也会遇到将使用的对象信息通过网络传输到另一端，又或者将对象信息保存下来，存储成文件形式保存在电脑硬盘上，以供下次提取使用，我们把 抽取对象信息并转化为二进制形式流的过程称之为序列化过程。 持久化 将信息持久化指的是将信息存储在不易失媒介上，内存上的信息在电脑断电后都会消失，而诸如硬盘、磁带等设备上的信息不会丢失，所以称这些数据是持久的，所以和数据库相关的层也会被称为持久化层，因为他们的工作就是将数据持久化存储。 transient 意义transient，英文名字就是瞬态的意思，意思是这个信息只是暂时在这个特定情况有意义，和计算机中持久的相对，需要持久化的信息代表这个信息在长远有一定意义。 java中对transient关键字的作用有如下描述： Variables may be marked transient to indicate that they are not part of the persistent state of an object. —— 摘自java手册 当类成员字段被表明为transient时，则表明这个字段信息不具有将其持久保存或转化的意义。 transient只能用在类字段上，如果加上，表示该字段不需要转化，否则将其转化。Attention：不是所有的对象都能转化，只有实现了serialiable接口的类成员对象才能转化 1234class Point implements Serializable{ int x, y; //这两个会被序列化 transient float rho, theta; //这两个字段信息不会被转化} serializable接口transient关键字与serialiable接口 意义区分 java使用serializable接口来标记一个类是否可以序列化。 transient关键字则说明了某个字段是否需要序列化。 必须实现了serializable接口的类中再去使用transient关键字，否则没意义啊！毕竟你要先决定这个类可不可以序列化，再去决定需要序列化哪些信息。 serializable的实现 去看java源代码，发现serializable接口中并没有任何方法，是一个空的接口。 空的接口没什么意义啊，为什么要这么做呢？经查询，原来这个接口只是起到一个标记的作用，不具有其他意义，他告诉jvm这个类是可以序列化的。 那么具体的序列化是怎么实现的呢？ 通过ObjectOutputStream和ObjectInputStream两个类实现。 12objectOutputStream.writeObject(object /*参数为需要序列化的类*/); // 序列化objectInputStream.readObject(object); // 解序列化 例子1234567891011121314151617181920212223242526272829303132333435363738class NameStore implements Serializable{ private String firstName; private transient String middleName; //这个字段不会被序列化 private String lastName; public NameStore (String fName, String mName, String lName){ this.firstName = fName; this.middleName = mName; this.lastName = lName; } public String toString(){ StringBuffer sb = new StringBuffer(40); sb.append(\"First Name : \"); sb.append(this.firstName); sb.append(\"Middle Name : \"); sb.append(this.middleName); sb.append(\"Last Name : \"); sb.append(this.lastName); return sb.toString(); }}public class TransientExample{ public static void main(String args[]) throws Exception { NameStore nameStore = new NameStore(\"Steve\", \"Middle\",\"Jobs\"); ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(\"nameStore\")); // writing to object o.writeObject(nameStore); o.close(); ArrayList // reading from object ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"nameStore\")); NameStore nameStore1 = (NameStore)in.readObject(); System.out.println(nameStore1); }} 12输出： First Name : Steve Middle Name : null Last Name : Jobs 可见，MiddleName没有被序列化。 FAQ 什么样的数据可以序列化，什么样的不可以呢？ 什么样的对象从根本来说都可以序列化，但是有的对象序列化是没有意义的，比如socket和文件等，所以这些类没有实现Serializable接口，也就不能序列化。 很多类种有SerialVersionUID，它是用来干嘛的？ 这个UID为每个类生成了一个唯一标识符，如此jvm可以利用这个标识符来比较序列化和解序列化过程中两个类是不是相同，以确保解序列化时的类加载正确。如果你没有自己主动生成，jvm会自动帮你制定一个。 参考1.java规范说明 2.Java: What can and what can’t be serialized? 3.Why does Java have transient fields? 4.Although the Serializable interface in Java has no methods, no fields, it can achieve its function. How?","link":"/2020/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/transient%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"指数基金","slug":"指数基金","link":"/tags/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/"},{"name":"KSUM","slug":"KSUM","link":"/tags/KSUM/"},{"name":"计算复杂度","slug":"计算复杂度","link":"/tags/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"gitignore","slug":"gitignore","link":"/tags/gitignore/"},{"name":"SSM","slug":"SSM","link":"/tags/SSM/"},{"name":"vector","slug":"vector","link":"/tags/vector/"},{"name":"随机算法","slug":"随机算法","link":"/tags/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"},{"name":"shadowsocks","slug":"shadowsocks","link":"/tags/shadowsocks/"},{"name":"权值算法","slug":"权值算法","link":"/tags/%E6%9D%83%E5%80%BC%E7%AE%97%E6%B3%95/"},{"name":"分支限界","slug":"分支限界","link":"/tags/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"前K大数","slug":"前K大数","link":"/tags/%E5%89%8DK%E5%A4%A7%E6%95%B0/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"前向星","slug":"前向星","link":"/tags/%E5%89%8D%E5%90%91%E6%98%9F/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"交集","slug":"交集","link":"/tags/%E4%BA%A4%E9%9B%86/"},{"name":"循环","slug":"循环","link":"/tags/%E5%BE%AA%E7%8E%AF/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"字节流","slug":"字节流","link":"/tags/%E5%AD%97%E8%8A%82%E6%B5%81/"},{"name":"字符流","slug":"字符流","link":"/tags/%E5%AD%97%E7%AC%A6%E6%B5%81/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"KNN","slug":"KNN","link":"/tags/KNN/"},{"name":"树同构","slug":"树同构","link":"/tags/%E6%A0%91%E5%90%8C%E6%9E%84/"},{"name":"随机数","slug":"随机数","link":"/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"transient","slug":"transient","link":"/tags/transient/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}],"categories":[{"name":"理财","slug":"理财","link":"/categories/%E7%90%86%E8%B4%A2/"},{"name":"计算机","slug":"计算机","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"基金","slug":"理财/基金","link":"/categories/%E7%90%86%E8%B4%A2/%E5%9F%BA%E9%87%91/"},{"name":"工具","slug":"计算机/工具","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B7%A5%E5%85%B7/"},{"name":"算法","slug":"计算机/算法","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/"},{"name":"框架","slug":"计算机/框架","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%86%E6%9E%B6/"},{"name":"数据结构","slug":"计算机/数据结构","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"常识","slug":"计算机/常识","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B8%B8%E8%AF%86/"},{"name":"设计模式","slug":"计算机/设计模式","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}